#' autotest
#'
#' Automatically test inputs to functions specified in a 'yaml' template.
#'
#' @param yaml A 'yaml' template as a character vector, either hand-coded or
#' potentially loaded via \link{readLines} function or similar. Should generally
#' be left at default of 'NULL', with template specified by 'filename'
#' parameter.
#' @param filename Name (potentially including path) of file containing 'yaml'
#' template. See \link{at_yaml_template} for details of template. Default uses
#' template generated by that function, and held in local './tests' directory.
#' @param quiet If 'FALSE', provide printed output on screen.
#' @return Nothing
#' @export
autotest <- function (yaml = NULL, filename = NULL, quiet = FALSE) {

    res <- parse_yaml_template (yaml = yaml, filename = filename)

    reports <- NULL

    for (i in seq (res$parameters)) {
        this_fn <- names (res$parameters) [i]
        params <- get_params (res, i, this_fn)
        params <- params [which (params != "NULL")]
        classes <- res$classes [[i]]

        reports <- rbind (reports,
                          autotest_rectangular (params,
                                                this_fn,
                                                classes,
                                                quiet))
        reports <- rbind (reports,
                          autotest_vector (params,
                                           this_fn,
                                           classes,
                                           quiet))
        reports <- rbind (reports,
                          autotest_single (res$package,
                                           params,
                                           this_fn,
                                           quiet))
        reports <- rbind (reports,
                          autotest_return (res$package,
                                           params,
                                           this_fn,
                                           attr (yaml, "package")))

        if (!quiet)
            message (cli::col_green (cli::symbol$tick, " ", this_fn))
    }

    if (!is.null (reports)) {
        # add hash to reports
        if (is.null (yaml) & !is.null (filename))
            yaml <- readLines (filename)
        reports$yaml_hash <- digest::digest (yaml)

        reports <- reports [which (!duplicated (reports)), ]
        rownames (reports) <- NULL
    }

    return (reports)
}

#' autotest_package
#'
#' Automatically test an entire package by converting examples to `yaml` format
#' and submitting each to the \link{autotest} function.
#'
#' @param package Name of package to be 'autotested'
#' @param exclude Character vector containing names of any functions to be
#' excluded from 'autotesting'
#' @param quiet If 'FALSE', provide printed output on screen.
#' @export
autotest_package <- function (package, exclude = NULL, quiet = FALSE) {
    if (!quiet)
        message (cli::col_yellow (cli::symbol$line),
                 cli::col_green (" parsing all package examples"),
                 appendLF = FALSE)
    exs <- examples_to_yaml (package, exclude = exclude)
    if (!quiet)
        message ("\r", cli::col_green (cli::symbol$tick,
                 " parsed all package examples"))
    res <- NULL
    for (i in seq_along (exs)) {
        yaml <- exs [[i]]
        attr (yaml, "package") <- package
        fn_name <- fn_from_yaml (yaml)
        res <- rbind (res, autotest (yaml = yaml, quiet = TRUE))
        if (!quiet)
            message (cli::col_green (cli::symbol$tick, " [",
                                     i, " / ", length (exs),
                                     "]: ", fn_name [1]))
    }
    res <- res [which (!duplicated (res)), ]

    no_examples <- fns_without_examples (package)
    if (length (no_examples) > 0) {
        cnt <- "This function has no documented example"
        for (i in no_examples) {
            rtemp <- report_object (type = "warning",
                                    fn_name = i,
                                    operation = "<see content>",
                                    content = cnt)
            rtemp$yaml_hash <- NA_character_
            res <- rbind (res, rtemp)

        }
    }

    attr (res, "package") <- package
    if (pkg_is_source (package)) {
        desc <- readLines (file.path (package, "DESCRIPTION"))
        attr (res, "packageName") <-
            gsub ("Package:\\s?", "", desc [grep ("^Package\\:", desc)])
        attr (res, "packageVersion") <-
            gsub ("^Version:\\s+", "", desc [grep ("^Version:", desc)])
        attr (res, "githash") <- get_git_hash (package)
    } else {
        attr (res, "packageName") <- package
        attr (res, "packageVersion") <- utils::packageVersion (package)
    }

    res <- tibble::tibble (res)
    class (res) <- c ("autotest_package", class (res))

    return (res)
}

# Extract function name from yaml; used only to screen dump in autootest_package
fn_from_yaml <- function (yaml) {
    x <- yaml::yaml.load (yaml)
    nms <- vapply (x$functions, names, character (1))
    return (unique (nms))
}
