#' autotest_yaml
#'
#' Automatically test inputs to functions specified in a 'yaml' template.
#'
#' @param yaml A 'yaml' template as a character vector, either hand-coded or
#' potentially loaded via \link{readLines} function or similar. Should generally
#' be left at default of 'NULL', with template specified by 'filename'
#' parameter.
#' @param filename Name (potentially including path) of file containing 'yaml'
#' template. See \link{at_yaml_template} for details of template. Default uses
#' template generated by that function, and held in local './tests' directory.
#' @param test If `FALSE`, return only descriptions of tests which would be run
#' with `test = TRUE`, without actually running them.
#' @param quiet If 'FALSE', provide printed output on screen.
#' @return An `autotest_pkg` object, derived from a \pkg{tibble}, detailing
#' instances of unexpected behaviour for every parameter of every function.
#'
#' @examples
#' \dontrun{
#' yaml_list <- examples_to_yaml (package = "stats", functions = "reshape")
#' res <- autotest_yaml (yaml = yaml_list)
#' }
#' @export
autotest_yaml <- function (yaml = NULL,
                           filename = NULL,
                           test = TRUE,
                           quiet = FALSE) {

    if (is.null (yaml) & is.null (filename)) {
        stop ("either yaml or filename must be given")
    } else if (!is.null (filename)) {
        yaml <- readLines (filename)
        pkg <- strsplit (yaml [grep ("^package:", yaml)],
                         "^package: ") [[1]] [2]
        attr (yaml, "package") <- pkg
    }

    if (is.character (yaml) & !is.null (attr (yaml, "package"))) {
        yaml <- list (yaml)
    }

    msg <- paste0 ("yaml must be either a single character vector ",
                   "representing a yaml 'autotest' object, or a list ",
                   "of such objects")
    if (!is.list (yaml))
        stop (msg)

    # Ensure anything passed as list represents valid yaml input:
    if (!is.character (yaml [[1]]) & !is.null (attr (yaml [[1]], "package")))
        stop (msg)

    reports <- lapply (yaml, function (i)
                      autotest_single_yaml (i, filename, test, quiet))
    reports <- do.call (rbind, reports)

    if (!is.null (reports)) {
        reports <- tibble::tibble (reports)
        class (reports) <- c ("autotest_package", class (reports))
    }

    return (reports)
}

#' Test one 'yaml' input file
#'
#' @inheritParams autotest_yaml
#' @noRd
autotest_single_yaml <- function (yaml = NULL,
                                  filename = NULL,
                                  test = TRUE,
                                  quiet = FALSE) {

    # yaml templates can be preprocessing only, with no direct function calls:
    if (!any (grepl ("- parameters:$", yaml)))
        return (NULL)

    res <- parse_yaml_template (yaml = yaml, filename = filename)

    reports <- NULL

    for (i in seq_along (res$parameters)) {
        this_fn <- names (res$parameters) [i]
        params <- get_params (res, i, this_fn)
        params <- params [which (params != "NULL")]
        param_types <- get_param_types (params)

        test_obj <- autotest_obj (package = res$package,
                                  fn_name = names (res$parameters) [i],
                                  parameters = params,
                                  parameter_types = param_types,
                                  class = NULL,
                                  classes = res$classes [[i]],
                                  env = new.env (),
                                  test = test,
                                  quiet = quiet)

        reports <- rbind (reports, autotest_rectangular (test_obj))

        reports <- rbind (reports, autotest_vector (test_obj))

        reports <- rbind (reports, autotest_single (test_obj))

        reports <- rbind (reports, autotest_return (test_obj))

        if (!quiet)
            message (cli::col_green (cli::symbol$tick, " ", this_fn))
    }

    if (!is.null (reports)) {
        # add hash to reports
        if (is.null (yaml) & !is.null (filename))
            yaml <- readLines (filename)
        reports$yaml_hash <- digest::digest (yaml)

        reports <- reports [which (!duplicated (reports)), ]
        rownames (reports) <- NULL
    }

    return (reports)
}

#' autotest_package
#'
#' Automatically test an entire package by converting examples to `yaml` format
#' and submitting each to the \link{autotest_yaml} function.
#'
#' @param package Name of package to be 'autotested'
#' @param functions Optional character vector containing names of functions of
#' nominated package to be included in 'autotesting'.
#' @param exclude Optional character vector containing names of any functions of
#' nominated package to be excluded from 'autotesting'.
#' @inheritParams autotest_yaml
#' @export
autotest_package <- function (package,
                              functions = NULL,
                              exclude = NULL,
                              test = FALSE,
                              quiet = FALSE) {

    exclude <- exclude_functions (package, functions, exclude)

    exs <- examples_to_yaml (package, exclude = exclude, quiet = quiet)

    if (!quiet) {
        txt <- paste0 ("autotesting ", get_package_name (package))
        cli::cli_h2 (cli::col_green (txt))
    }

    res <- NULL
    for (i in seq_along (exs)) {
        yaml <- exs [[i]]
        attr (yaml, "package") <- package
        fn_name <- fn_from_yaml (yaml)
        res <- rbind (res,
                      autotest_yaml (yaml = yaml, test = test, quiet = TRUE))
        if (!quiet)
            message (cli::col_green (cli::symbol$tick, " [",
                                     i, " / ", length (exs),
                                     "]: ", fn_name [1]))
    }
    res <- res [which (!duplicated (res)), ]

    no_examples <- fns_without_examples (package)
    no_examples <- no_examples [no_examples %in% unique (res$fn_name)]
    if (length (no_examples) > 0) {
        cnt <- "This function has no documented example"
        for (i in no_examples) {
            rtemp <- report_object (type = "warning",
                                    fn_name = i,
                                    operation = "<see content>",
                                    content = cnt)
            rtemp$yaml_hash <- NA_character_
            res <- rbind (res, rtemp)

        }
    }

    attr (res, "package") <- package

    if (pkg_is_source (package)) {

        desc <- file.path (package, "DESCRIPTION")
        attr (res, "packageName") <- read.dcf (desc, "Package")
        attr (res, "packageVersion") <- read.dcf (desc, "Version")
        attr (res, "githash") <- get_git_hash (package)

    } else {

        attr (res, "packageName") <- package
        attr (res, "packageVersion") <- utils::packageVersion (package)

    }

    res <- tibble::tibble (res)
    class (res) <- c ("autotest_package", class (res))

    return (res)
}

# Extract function name from yaml; used only to screen dump in autootest_package
fn_from_yaml <- function (yaml) {

    x <- yaml::yaml.load (yaml)
    nms <- vapply (x$functions, names, character (1))
    return (unique (nms))

}

#' autotest_types
#'
#' List all types of 'autotests' currently implemented.
#'
#' @return An `autotest` object with each row listing one unique type of test
#' which can be applied to every parameter (of the appropriate class) of each
#' function.
#'
#' @export
autotest_types <- function () {

    res <- rbind (autotest_rectangular (),
                  autotest_vector (),
                  autotest_single ())
    res <- tibble::tibble (res)

    class (res) <- c ("autotest_package", class (res))

    return (res)
}
