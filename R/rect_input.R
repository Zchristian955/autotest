#' autotest_rectangular
#'
#' Automatically test a variety of rectangular objects as inputs to functions
#' specified in a 'yaml' template.
#'
#' @param yaml A 'yaml' template as a character vector, either hand-coded or
#' potentially loaded via \link{readLines} function or similar. Should generally
#' be left at default of 'NULL', with template specified by 'filename'
#' parameter.
#' @param filename Name (potentially including path) of file containing 'yaml'
#' template. See \link{at_yaml_template} for details of template. Default uses
#' template generated by that function, and held in local './tests' directory.
#' @param quiet If 'FALSE', provide printed output on screen.
#' @return Nothing
#' @export
autotest_rectangular <- function (yaml = NULL, filename = NULL, quiet = FALSE) {
    res <- parse_yaml_template (yaml = yaml, filename = filename)

    . <- NULL # suppress no visible binding note

    if (!quiet)
        message (cli::symbol$star, " Testing functions:")

    for (i in seq (res$parameters)) {
        this_fn <- names (res$parameters) [i]

        if (!quiet)
            cli::cli_ul (this_fn)

        params <- get_params (res, i, this_fn)

        #out <- do.call (this_fn, params)
        rect_index <- which (vapply (params, function (i)
                                     length (dim (i)) == 2, logical (1)))
        for (r in rect_index) {
            x <- params [[r]]
            params_r <- params

            params_r [[r]] <- data.frame (x)
            res1 <- do.call (this_fn, params_r)

            params_r [[r]] <- tibble::tibble (x)
            res2 <- do.call (this_fn, params_r)

            params_r [[r]] <- data.table::data.table (x)
            res3 <- do.call (this_fn, params_r)

            testthat::expect_identical (res1, res2)
            testthat::expect_identical (res1, res3)

            # extended class structure should still work:
            params_r [[r]] <- structure (x, class = c ("newclass", class (x)))
            res4 <- do.call (this_fn, params_r)
            testthat::expect_identical (res1, res4)

            # new class structure which exposes 'List` structure of `data.frame`
            # and should generally fail:
            params_r [[r]] <- structure (x, class = c ("newclass"))
            testthat::expect_error (do.call (this_fn, params_r))
        }
    }
}

# extract the i-th list of parameters to pass to function
get_params <- function (res, i, this_fn) {
    p <- unlist (res$parameters [[i]])
    p_keys <- names (p)
    p_vals <- unname (p)

    . <- NULL # suppress no visible binding note
    pre <- res$preprocess [[i]]
    e <- new.env ()
    for (p in pre) {
        gsub ("`", "", p) %>%
            parse (text = .) %>%
            eval (envir = e)
    }

    params <- list ()
    for (p in seq (p_keys)) {
        this_val <- p_vals [p]
        if (grepl ("::", this_val)) {
            this_pkg <- strsplit (p_vals [p], "::") [[1]] [1]
            if (!this_pkg %in% search ())
                library (this_pkg, character.only = TRUE)
            this_val <- parse (text = this_val) %>%
                eval (envir = as.environment (paste0 ("package:", this_pkg)))
        } else if (this_val %in% names (e))
            this_val <- parse (text = this_val) %>%
                eval (envir = e)

            params [[length (params) + 1]] <- this_val
            names (params) [length (params)] <- p_keys [p]
    }

    # Parse fn definition to get list of all parameters:
    pars <- at_get_fn_params (fn_name = this_fn, pkg_name = res$package)
    #pars <- c (pars, list (`3` = list (name = "stuff", val = 10)))
    nms <- vapply (pars, function (i) i$name, character (1))
    pars <- pars [which (!nms %in% names (params))]
    for (p in pars) {
        params [[length (params) + 1]] <- p$val
        names (params) [length (params)] <- p$name
    }

    return (params)
}
