#' autotest
#'
#' Automatically test inputs to functions specified in a 'yaml' template.
#'
#' @param yaml A 'yaml' template as a character vector, either hand-coded or
#' potentially loaded via \link{readLines} function or similar. Should generally
#' be left at default of 'NULL', with template specified by 'filename'
#' parameter.
#' @param filename Name (potentially including path) of file containing 'yaml'
#' template. See \link{at_yaml_template} for details of template. Default uses
#' template generated by that function, and held in local './tests' directory.
#' @param quiet If 'FALSE', provide printed output on screen.
#' @return Nothing
#' @export
autotest <- function (yaml = NULL, filename = NULL, quiet = FALSE) {

    res <- parse_yaml_template (yaml = yaml, filename = filename)

    if (!quiet)
        message (cli::col_green (cli::symbol$star, " Testing functions:"))

    for (i in seq (res$parameters)) {
        this_fn <- names (res$parameters) [i]
        message ("\n", cli::rule (cli::col_green (paste0 ("Testing ", this_fn)),
                                  line_col = "green"))

        params <- get_params (res, i, this_fn)
        params <- params [which (!params == "NULL")]
        classes <- res$classes [[i]]

        chk1 <- autotest_rectangular (params, this_fn, classes, quiet)
        chk2 <- autotest_vector (params, this_fn, classes, quiet)
        chk3 <- autotest_single (res$package, params, this_fn, quiet)
        chk4 <- autotest_return (res$package, params, this_fn)

        if (chk1 && chk2 && chk4)
            message (cli::col_green (cli::symbol$tick, " ", this_fn))
        else
            message (cli::col_red (cli::symbol$cross), " ", cli::col_yellow (this_fn))
    }
}


autotest_rectangular <- function (params, this_fn, classes, quiet) {

    chk <- TRUE # Not implemented; TODO: Implement
    
    rect_index <- which (vapply (params, function (i)
                                 length (dim (i)) == 2, logical (1)))
    for (r in rect_index) {
        x <- params [[r]]
        params_r <- params

        params_r [[r]] <- data.frame (x)
        res1 <- do.call (this_fn, params_r)

        params_r [[r]] <- tibble::tibble (data.frame (x))
        res2 <- do.call (this_fn, params_r)

        params_r [[r]] <- data.table::data.table (x)
        res3 <- do.call (this_fn, params_r)

        chk_dims (this_fn, params, r, res1, res2)
        chk_names (this_fn, params, r, res1, res2)
        chk_columns (this_fn, params, r, res1, res2)

        chk_dims (this_fn, params, r, res1, res3)
        chk_names (this_fn, params, r, res1, res3)
        chk_columns (this_fn, params, r, res1, res3)

        # Modify class definitions for rectangular inputs if not excluded by
        # yaml class definitions
        if (!names (params_r) [rect_index [r]] %in% names (classes)) {
            # extended class structure should still work:
            params_r [[r]] <- structure (x, class = c ("newclass", class (x)))
            res4 <- do.call (this_fn, params_r)

            chk_dims (this_fn, params, r, res1, res4)
            chk_names (this_fn, params, r, res1, res4)
            chk_columns (this_fn, params, r, res1, res4)

            # new class structure which exposes 'List` structure of `data.frame`
            # and should generally fail:
            params_r [[r]] <- structure (x, class = c ("newclass"))
            res <- tryCatch (do.call (this_fn, params_r),
                             error = function (e) "error")
            if (!length (res) == 1 & res == "error") {
                #warning ("Function [", this_fn, "] should error on ... ",
                #         call. = FALSE, immediate. = TRUE)
            }
        } else {
            # TODO: Implement check for all nominated classes
        }
    }
    return (chk)
}

chk_dims <- function (this_fn, params, r, res1, res2) {
    if (!identical (dim (res1), dim (res2))) {
        warning ("Function [", this_fn, "] errors on rectangular input for [",
                 names (params) [r], "]: Dimensions differ between ",
                 class (res1) [1], " and ", class (res2) [1], " inputs",
                 call. = FALSE, immediate. = TRUE)
    }
}

chk_names <- function (this_fn, params, r, res1, res2) {
    if (!identical (names (res1), names (res2))) {
        warning ("Function [", this_fn, "] errors on rectangular input for [",
                 names (params) [r], "]: Column names differ between ",
                 class (res1) [1], " and ", class (res2) [1], " inputs",
                 call. = FALSE, immediate. = TRUE)
    }
}

chk_columns <- function (this_fn, params, r, res1, res2) {
    for (i in seq (ncol (res1))) {
        if (!identical (res1 [[i]], res2 [[i]])) {
            warning ("Function [", this_fn, "] errors on rectangular input for [",
                     names (params) [r], "]: Column [", names (res1) [i],
                     "] differs between ",
                     class (res1) [1], " and ", class (res2) [1], " inputs",
                     call. = FALSE, immediate. = TRUE)
        }
    }
}

autotest_vector <- function (params, this_fn, classes, quiet) {

    chk <- TRUE

    null_params <- NULL
    if (any (params == "NULL")) {
        null_params <- params [params == "NULL"]
        params <- params [params != "NULL"]
    }

    vec_index <- which (vapply (params, function (i)
                                length (i) > 1 && is.null (dim (i)), logical (1)))
    for (v in vec_index) {
        params_v <- params

        res1 <- tryCatch (do.call (this_fn, params_v),
                          warning = function (w) w,
                          error = function (e) e)
        warn <- FALSE
        if (methods::is (res1, "warning")) {
            cli::cli_text (cli::col_yellow ("function [", this_fn,
                                            "] issued a Warning: ",
                                            res1$message))
            warn <- TRUE
            res1 <- suppressWarnings (do.call (this_fn, params_v))
        }

        # int columns submitted as double should return different result:
        if (typeof (params_v [[v]]) == "integer") {
            params_v [[v]] <- as.numeric (params_v [[v]])
            if (warn)
                res2 <- suppressWarnings (do.call (this_fn, params_v))
            else
                res2 <- do.call (this_fn, params_v)
            if (!identical (res1, res2)) {
                warning ("Function [", this_fn, "] returns different values when ",
                         "assumed int-valued parameter [", names (params) [v],
                         "] is submitted as double.\n Error message: ",
                         "different classes when submitted as ", names (params) [v],
                         res3$message, call. = FALSE, immediate. = TRUE)
            }
            params_v <- params
        }

        # class definitions for vector columns should be ignored
        if (!names (params_v) [vec_index [v]] %in% names (classes)) {
            x <- params_v [[v]]
            class (x) <- "different"
            params_v [[v]] <- x
            res3 <- tryCatch (
                              do.call (this_fn, params_v),
                              warning = function (w) w,
                              error = function (e) e)
            if (methods::is (res3, "error")) {
                chk <- FALSE
                warning ("Function [", this_fn, "] errors on vector columns with ",
                         "different classes when submitted as ", names (params) [v],
                         "\n  Error message: ", res3$message,
                         call. = FALSE, immediate. = TRUE)
            } else {
                # TODO: Expectation - they need not be identical, because class
                # def may be carried over to result
                #expect_identical (res1, res3)
            }
            params_v <- params
        } else {
            # TODO: Implement check for all nominated classes
        }

        # List-columns
        x <- params_v [[v]]
        x <- I (as.list (x))
        params_v [[v]] <- x
        res4 <- tryCatch (
                          do.call (this_fn, params_v),
                          warning = function (w) w,
                          error = function (e) e)
        if (methods::is (res4, "error")) {
            chk <- FALSE
            warning ("Function [", this_fn, "] errors on list-columns ",
                     "when submitted as ", names (params) [v],
                     "\n  Error message: ", res4$message,
                     call. = FALSE, immediate. = TRUE)
        } else {
            # TODO: Expectation here too
            #expect_identical (res1, res4)
        }
    }

    return (chk)
}

autotest_single <- function (pkg, params, this_fn, quiet) {

    chk <- TRUE

    null_params <- NULL
    if (any (params == "NULL")) {
        null_params <- params [params == "NULL"]
        params <- params [params != "NULL"]
    }

    index <- which (vapply (params, function (j)
                            is.null (dim (j)) && length (j) == 1, logical (1)))
    for (i in index) {
            params_i <- params

            res1 <- tryCatch (do.call (this_fn, params_i),
                              warning = function (w) w,
                              error = function (e) e)
            warn <- FALSE
            if (methods::is (res1, "warning")) {
                cli::cli_text (cli::col_yellow ("function [", this_fn,
                                                "] issued a Warning: ",
                                                res1$message))
                warn <- TRUE
                res1 <- suppressWarnings (do.call (this_fn, params_i))
            }

            p_i <- params_i [[i]]
            is_int <- FALSE
            if (is.numeric (p_i))
                if (p_i == round (p_i))
                    is_int <- TRUE
            if (!is_int)
                is_int <- is.integer (p_i)

            if (is_int) {
                int_range <- get_int_range (this_fn, params, i)
                if (!any (is.finite (int_range))) {
                    cli::cli_text (cli::col_yellow ("Parameter [",
                                    names (params_i) [i],
                                    "] permits unrestricted integer inputs"))
                } else if (!is.null (int_range)) {
                    cli::cli_text (cli::col_yellow ("Parameter [",
                                    names (params_i) [i],
                                    "] responds to integer values in [",
                                    paste0 (int_range, collapse = ", "), "]"))
                    rd <- get_Rd_param (package = pkg,
                                        fn_name = this_fn,
                                        param_name = names (params_i) [i])
                    range_in_rd <- vapply (int_range, function (j)
                                           grepl (j, rd), logical (1))
                    chk <- all (range_in_rd)
                    if (chk) 
                        message (cli::col_green (cli::symbol$tick),
                                 cli::col_yellow (" Parameter range for ",
                                                  names (params) [i], 
                                                  " is documented"))
                    else
                        warning (cli::col_red (cli::symbol$cross),
                                 cli::col_yellow (" Parameter range for ",
                                                  names (params) [i],
                                                  " is NOT documented"))
                } else
                    chk <- FALSE
            }
    }

    return (chk)
}
