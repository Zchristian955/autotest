
---
title: "autotest"
output:
  rmarkdown::html_vignette:
    self_contained: no

  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = TRUE,
  message = TRUE,
  width = 120,
  comment = "#>",
  fig.retina = 2,
  fig.path = "README-"
)
```

<!-- badges: start -->

[![R build
status](https://github.com/ropenscilabs/autotest/workflows/R-CMD-check/badge.svg)](https://github.com/ropenscilabs/autotest/actions?query=workflow%3AR-CMD-check)
[![codecov](https://codecov.io/gh/ropenscilabs/autotest/branch/master/graph/badge.svg)](https://codecov.io/gh/ropenscilabs/autotest)
[![Project Status:
Concept](https://www.repostatus.org/badges/latest/concept.svg)](https://www.repostatus.org/#concept)
<!-- badges: end -->

# autotest


Automatic mutation testing of R packages. Mutation in the sense of mutating
inputs (parameters) to function calls, rather than mutation of underlying code
(see, for example, [`mutant`](https://github.com/ropensci/mutant) for that).
`autotest` primarily works by scraping documented examples for all functions,
and mutating the parameters input to those functions.

**This package is very unstable and subject to ongoing development (Nov 2020)**

## Installation

Not yet on CRAN, so must be installed from remote repository host systems using
any one of the following options:
```{r gh-installation, eval = FALSE}
# install.packages("remotes")
remotes::install_git("https://git.sr.ht/~mpadge/autotest")
remotes::install_bitbucket("mpadge/autotest")
remotes::install_gitlab("mpadge/autotest")
remotes::install_github("ropenscilabs/autotest")
```

The package can then be loaded the usual way:
```{r load-fakey, eval = FALSE}
library (autotest)
```
```{r load, echo = FALSE, message = FALSE}
devtools::load_all (".", export_all = FALSE)
```

## Usage

The simply way to use the package is

```{r autotest-example, eval = FALSE}
x <- autotest_package ("<package>")
```
The argument to `autotest_package()` can either be the name of an installed
package, or a path to a local directory containing the source for a package.
The result is a `data.frame` of errors, warnings, and other diagnostic messages
issued during package `auotest`-ing.

## How Does It Work? (Part 1)

The `autotest_package()` function returns the results of implementing all tests
on a given package. These results only indicate any divergence from expected
behaviour, whether unexpected errors, warnings, or other behaviour. An ideal
result is that `autotest_package()` returns nothing (strictly, `NULL`),
indicating that all test passed successfully. To see which tests were
performed, or to see which tests would be performed prior to actually running
them, the function has a `test` parameter with a default value of `TRUE`.
Setting this to `FALSE` returns a (generally much larger) `data.frame` of all
tests which would be conducted on the nominated package.

Tests can also be selectively specified through an `exclude` parameter, used to
nominate functions to exclude from tests. The following code illustrates,
starting by excluding all functions except one.

```{r stats-var1}
fns <- ls ("package:stats")
exclude <- fns [which (!fns == "var")]
autotest_package (package = "stats", exclude = exclude, test = FALSE)
```

That result details the 130 tests which would be applied to the `var` function
from the `stats` package. These 130 tests yield the following results:

```{r stats-var-test}
autotest_package (package = "stats", exclude = exclude, test = TRUE)
```

## How Does It Work (Part 2)

The tests themselves are controlled by `yaml` files, internally generated by
calling `autotest_package()`. These `yaml` test specifications can be
explicitly extracted for a given package or function(s) thereof with the
`examples_to_yaml()` function, as demonstrated in the following code.

```{r yaml1}
yaml <- examples_to_yaml (package = "stats", functions = "var")
length (yaml)
print (yaml [[1]], width = 20)
```

That `yaml` contains the values of all parameters used in one function call
within the documented example code. Only explicitly specified values are
declared, with all other parameters assuming default values. All parameters of
a function are then mutated, whether explicitly specified or default. 

The "preprocess" lines of the `yaml` include any lines which assign values to
named objects, and which may be used in any subsequent line of a given `yaml`.
That `yaml` can also be used to generate lists of tests (with `test = FALSE`),
or results of applying those tests (with `test = TRUE`), using the function,
`autotest()`:

```{r yaml-test}
autotest (yaml = yaml, test = FALSE)
autotest (yaml = yaml, test = TRUE)
```


## Prior work

1. The
   [`great-expectations`](https://github.com/great-expectations/great_expectations)
   framework for python, described in [this medium
   article](https://medium.com/@expectgreatdata/down-with-pipeline-debt-introducing-great-expectations-862ddc46782a).
2. [`QuickCheck`](https://hackage.haskell.org/package/QuickCheck) for Haskell
3. [`mutate`](https://github.com/mbj/mutant) for ruby.
