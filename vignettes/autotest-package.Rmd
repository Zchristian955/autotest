---
title: "Using autotest to develop a package"
author: 
  - "Mark Padgham"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        number_sections: false
        theme: flatly
vignette: >
  %\VignetteIndexEntry{Using autotest to develop a package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = TRUE,
  message = TRUE,
  width = 120,
  comment = "#>",
  fig.retina = 2,
  fig.path = "README-"
)
```

This vignette demonstrates the easiest way to use `autotest`, which is to apply
it continuously through the entire process of package development. The best way
to understand the process is to obtain a local copy of the vignette itself from
[this
link](https://github.com/ropenscilabs/autotest/blob/master/vignettes/autotest-package.Rmd),
and step through the code. We begin by constructing a simple package in the
local
[`tempdir()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/tempfile.html).

<details closed>

<summary> <span title="Click to Expand"> Package Construction </span> </summary>

To create a package in one simple line, we use
[`usethis::create_package()`](https://usethis.r-lib.org/reference/create_package.html),
and name our package `"demo"`.

```{r create_package}
path <- file.path (tempdir (), "demo")
usethis::create_package (path, check_name = FALSE, open = FALSE)
```

We also set our license to GPL3, to avoid needing an extra "License" file.

```{r license}
wd <- setwd (path)
usethis::use_gpl3_license ()
setwd (wd)
```

The structure looks like this:

```{r dir_tree}
fs::dir_tree (path)
```

</details><br>

Having constructed a minimal package structure, we can then insert some code in
the `R/` directory, including initial [`roxygen2`](https://roxygen2.r-lib.org)
documentation lines, and use the [`roxygenise()`
function](https://roxygen2.r-lib.org/reference/roxygenize.html) to create the
corresponding `man` files.

```{r first-fn}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @return Something else",
           "#' @export",
           "my_function <- function (x) {",
           "  return (x + 1)",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
roxygen2::roxygenise (path)
```

Our package now looks like this:

```{r dir_tree2}
fs::dir_tree (path)
```

We can already apply `autotest` to that package to see what happens, first
ensuring that we've loaded the package ready to use.

```{r autotest1}
#library (autotest)
devtools::load_all (".", export_all = FALSE)
x0 <- autotest_package (path)
DT::datatable (x0, options = list (dom = "t")) # display table only
```

## Adding examples to our code

That tells us straight away that we need to add an example to our function
documentation. So let's do that by inserting extra lines into the `code`
defined above, and see what happens.

```{r autotest-FALSE}
code <- c (code [1:4],
           "#' @examples",
           "#' y <- my_function (x = 1)",
           code [5:length (code)])
writeLines (code, file.path (path, "R", "myfn.R"))
roxygen2::roxygenise (path)
x1 <- autotest_package (path)
DT::datatable (x1, options = list (dom = "t"))
```

The first thing to notice is the first column, which has `test_type = "dummy"`
for all rows. The [`autotest_package()`
function](https://ropenscilabs.github.io/autotest/reference/autotest_package.html)
has a parameter `test` with a default value of `FALSE`, so that the default
call demonstrated above does not actually implement the tests, rather it
returns an object listing all tests that would be performed with actually doing
so. Applying the tests by setting `test = TRUE` gives the following result.

```{r autotest-TRUE}
x2 <- autotest_package (path, test = TRUE)
DT::datatable (x2, options = list (dom = "t"))
```

Of the `r nrow(x1)` tests which were performed, only `r nrow(x2)` yielded
unexpected behaviour. The result of the test says that the parameter `x` is
"assumed to be a single numeric". `autotest` does its best to figure out what
types of inputs are expected for each parameter, and with the example only
demonstrating `x = 1`, assumes that `x` is always expected to be a single
value. We could resolve this by asserting that `length(x) == 1`, as follows:

```{r assert-length}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @return Something else",
           "#' @examples",
           "#' y <- my_function (x = 1)",
           "#' @export",
           "my_function <- function (x) {",
           "  if (length(x) > 1) {",
           "    warning(\"only the first value of x will be used\")",
           "    x <- x [1]",
           "  }",
           "  return (x + 1)",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
roxygen2::roxygenise (path)
```

This is then sufficient to pass all `autotest` tests and so return `NULL`.

```{r autotest-TRUE2}
autotest_package (path, test = TRUE)
```

## Vector input

The initial test results above suggested that the input was *assumed* to be of
length one. Let us now revert our function to its original format which
accepted vectors of length > 1, and include an example demonstrating such
input.

```{r vector-input}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @return Something else",
           "#' @examples",
           "#' y <- my_function (x = 1)",
           "#' y <- my_function (x = 1:2)",
           "#' @export",
           "my_function <- function (x) {",
           "  return (x + 1)",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
roxygen2::roxygenise (path)
```

Testing the package now gives:

```{r autotest-TRUE3}
x3 <- autotest_package (path, test = TRUE)
DT::datatable (x3, options = list (dom = "t"))
```

### List-column conversion

The above result reflects one of the standard tests, which is to determine
whether list-column formats are appropriately processed. List-columns commonly
arise when using (either directly or indirectly), the [`tidyr::nest()`
function](https://tidyr.tidyverse.org/reference/nest.html), or equivalently in
base R with the [`I` or `AsIs`
function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/AsIs.html).
They look like this:

```{r list-col-demo}
dat <- data.frame (x = 1:3, y = 4:6)
dat$x <- I (as.list (dat$x)) # base R
dat <- tidyr::nest (dat, y = y)
print (dat)
```

The use of packages like [`tidyr`](https://tidyr.tidyverse.org) and
[`purrr`](https://purrr.tidyverse.org) quite often leads to
[`tibble`](https://tibble.tidyverse.org)-class inputs which contain
list-columns. Any functions which fail to identify and appropriately respond to
such inputs may generate unexpected errors, and this `autotest` is intended to
enforce appropriate handling of these kinds of inputs. The following lines
demonstrate the kinds of results that can arise without such checks.

```{r mtcars-error, error = TRUE}
m <- mtcars
head (m, n = 2L)
m$mpg <- I (as.list (m$mpg))
head (m, n = 2L) # looks exaxtly the same
cor (m)
```

In contrast, many functions either assume inputs to be lists, and convert when
not, or implicitly `unlist`. Either way, such functions may respond entirely
consistently regardless of the presence of list-columns, like this:

```{r mtcars-okay}
m$mpg <- paste0 ("a", m$mpg)
class (m$mpg)
```

The list-column `autotest` is intended to enforce consistent behaviour in
response to list-column inputs. One way to identify list-column formats is to
check the value of `class(unclass(.))` of each column. The `unclass` function
is necessary to first remove any additional class attributes, such as `I` in
`dat$x` above. A modified version of our function which identifies and responds
to list-column inputs might look like this:

```{r list-col-input}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @return Something else",
           "#' @examples",
           "#' y <- my_function (x = 1)",
           "#' y <- my_function (x = 1:2)",
           "#' @export",
           "my_function <- function (x) {",
           "  if (methods::is (unclass (x), \"list\")) {",
           "    x <- unlist (x)",
           "  }",
           "  return (x + 1)",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
```

That change once again leads to clean `autotest` results:

```{r autotest-TRUE4}
autotest_package (path, test = TRUE)
```

Of course simply attempting to `unlist` a complex list-column may be dangerous,
and it may be preferable to issue some kind of message or warning, or even
either simply remove any list-columns entirely or generate an error. Replacing
the above, potentially dangerous, line, `x <- unlist (x)` with a simple
`stop("list-columns are not allowed")` will also produce clean `autotest`
results.

## Random numbers

Let us now extend our example to highlight a few more aspects of `autotest`, by
replacing the functional operation `x <- x + 1` to instead add a random
component via `x <- x + runif (1)`.

```{r runif}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @return Something else",
           "#' @examples",
           "#' y <- my_function (x = 1)",
           "#' y <- my_function (x = 1:2)",
           "#' @export",
           "my_function <- function (x) {",
           "  if (methods::is (unclass (x), \"list\")) {",
           "    x <- unlist (x)",
           "  }",
           "  return (x + stats::runif (1))",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
x4 <- autotest_package (path, test = TRUE)
DT::datatable (x4, options = list (dom = "t"))
```

That prompts a new diagnostic result that our functions does not generate
repeatable results when trivial noise is added. `autotest` expects all
functions to be able to generate repeatable results, and so all functions
should enable external specification of a seed used to generate random numbers,
generally through additional parameters. Let us then modify our function to
enable a random seed to be specified.

```{r runif-seed}
code <- c ("#' my_function",
           "#'",
           "#' @param x An input",
           "#' @param seed Random seed",
           "#' @return Something else",
           "#' @examples",
           "#' y <- my_function (x = 1)",
           "#' y <- my_function (x = 1:2)",
           "#' @export",
           "my_function <- function (x, seed = 1) {",
           "  if (methods::is (unclass (x), \"list\")) {",
           "    x <- unlist (x)",
           "  }",
           "  set.seed (seed)",
           "  return (x + stats::runif (1))",
           "}")
writeLines (code, file.path (path, "R", "myfn.R"))
roxygen2::roxygenise (path) # need to update docs with seed param
autotest_package (path, test = TRUE)
```

And that is sufficient to again generate clean results.

## Return results and documentation

Functions which return complicated results, such as objects with specific
classes, need to document those class types, and `autotest` compares return
objects with documentation to ensure that this is done. The following code
constructs a new function to demonstrate some of the ways `autotest` inspects
return objects.

```{r return-val}
code <- c ("#' my_function2",
           "#'",
           "#' @param x An input",
           "#' @examples",
           "#' y <- my_function2 (x = 1)",
           "#' @export",
           "my_function2 <- function (x) {",
           "  return (datasets::iris)",
           "}")
writeLines (code, file.path (path, "R", "myfn2.R"))
roxygen2::roxygenise (path) # need to update docs with seed param
x5 <- autotest_package (path, test = TRUE)
DT::datatable (x5, options = list (dom = "t"))
```

Several new diagnostic messages are then issued. The first is the same as was
initially triggered, because `autotest` presumes the example with `x = 1` to
indicate that parameter should be single valued, and so can be dealt with by
generating an error if `length(x) > 1`. The remainder happen because there is
no description of the return object. So let's try an updated version.

```{r return-val-2}
code <- c ("#' my_function2",
           "#'",
           "#' @param x An input",
           "#' @return The iris data set as dataframe",
           "#' @examples",
           "#' y <- my_function2 (x = 1)",
           "#' @export",
           "my_function2 <- function (x) {",
           "  if (length (x) > 1) stop (\"error\")",
           "  return (datasets::iris)",
           "}")
writeLines (code, file.path (path, "R", "myfn2.R"))
roxygen2::roxygenise (path) # need to update docs with seed param
x6 <- autotest_package (path, test = TRUE)
DT::datatable (x6, options = list (dom = "t"))
```

That result still contains a couple of diagnostic messages, but it is now
pretty clear what we need to do, which is to be precise with our specification
of the class of return object. The following then suffices to once again
generate clean `autotest` results.

```{r iris-update}
code [4] <- "#' @return The iris data set as data.frame"
writeLines (code, file.path (path, "R", "myfn2.R"))
roxygen2::roxygenise (path) # need to update docs with seed param
autotest_package (path, test = TRUE)
```
